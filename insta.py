from instaclient import InstaClient
from instaclient.errors import *
from credentials import *
import os
from datetime import datetime
from discord_webhook import DiscordWebhook, DiscordEmbed
import time


# Initialise Time
now = datetime.now()
init_time = now.strftime("%H:%M:%S")


# SCRAPE VARIABLES
# scrape_username = "USERNAME_TO_SCRAPE"
scrape_username = input("Enter an Instagram account's username to scrape it's data: ")

# ! SCRAPING

# Create a instaclient object. Place as driver_path argument the path that leads to where you saved the chromedriver.exe file
# client = InstaClient(driver_path='G:\Programming\insta-follow-tracker\chromedriver.exe', localhost_headless=True)
client = InstaClient(driver_path='G:\Programming\insta-follow-tracker\chromedriver.exe')

try:
    client.login(username=username, password=password) # Go through Login Procedure
except VerificationCodeNecessary:
    # This error is raised if the user has 2FA turned on.
    code = input('Enter the 2FA security code generated by your Authenticator App or sent to you by SMS')
    client.input_verification_code(code)
except SuspisciousLoginAttemptError as error:
    # This error is raised by Instagram
    if error.mode == SuspisciousLoginAttemptError.EMAIL:
        code = input('Enter the security code that was sent to you via email: ')
    else:
        code = input('Enter the security code that was sent to you via SMS: ')
    client.input_security_code(code)



# Scrape Instagram followers
try:
    # Scrapes the users followers into a Tuple.
    followers = client.get_followers(user=scrape_username, count=None, use_api=False, callback_frequency=25)
    # Changing from Tuple to List
    followers = followers[0]
except InvalidUserError:
    # Exception raised if the username is not valid
    print('The username is not valid')
except PrivateAccountError:
    # Exception raised if the account you are trying to scrape is private
    print('{} is a private account'.format(username))
except:
    client.disconnect()

# Scrape Instagram following
try:
    # Try to get the users following the
    following = client.get_following(user=scrape_username, count=None, use_api=False, callback_frequency=25)
    # Changing from Tuple to List
    following = following[0]
except InvalidUserError:
    # Exception raised if the username is not valid
    print('The username is not valid')
except PrivateAccountError:
    # Exception raised if the account you are trying to scrape is private
    print('{} is a private account'.format(username))
except:
    client.disconnect()

# Processing Data
following_me_only = list((set(followers) - set(following)))
following_them_only = list((set(following) - set(followers)))

# Debug Print Statements
print(following_me_only)
print(following_them_only)

# Closing the client to prevent memory leaks
client.disconnect()

# Reading File & comparing with new strings

# defining empty lists
old_following_me_only =  []
old_following_them_only = []

# Reading files
if os.path.exists('following_me_only.txt'):
    with open('following_me_only.txt', 'r') as filehandle:
        old_following_me_only = [current_place.rstrip() for current_place in filehandle.readlines()]
else:
    print("File does not exist, skipping reading...")
    
if os.path.exists('following_them_only.txt'):
    with open('following_them_only.txt', 'r') as filehandle:
        old_following_them_only = [current_place.rstrip() for current_place in filehandle.readlines()]
else:
    print("File does not exist, skipping reading...")

# Comparing old and current lists
if os.path.exists('following_me_only.txt') and os.path.exists('following_them_only.txt'):
    # Following me changes
    new_following_me_only = set(following_me_only) - set(old_following_me_only)
    nolonger_following_me_only = set(old_following_me_only) - set(following_me_only)

    # Following them changes
    new_following_them_only = set(following_them_only) - set(old_following_them_only)
    nolonger_following_them_only = set(old_following_them_only) - set(following_them_only)

else:
    print("Skipping Comparing old and current lists")

# Overwriting files with new data.
with open('following_me_only.txt', 'w') as filehandle:
    filehandle.writelines("%s\n" % user for user in following_me_only)

with open('following_them_only.txt', 'w') as filehandle:
    filehandle.writelines("%s\n" % user for user in following_them_only)


# Converting into comma separated string for Discord
new_following_me_only = (', '.join(new_following_me_only))
nolonger_following_me_only = (', '.join(nolonger_following_me_only))

new_following_them_only = (', '.join(new_following_them_only))
nolonger_following_them_only = (', '.join(nolonger_following_them_only))

# Splitting string into 1000 characters per list, since webhooks' embed description are limited to 1024 characters
# Maxmimum message length? Will split message(s) into this number if required.
split_length = 1000

new_following_me_only = [str[i:i+split_length] for i in range(0, len(str), split_length)]
nolonger_following_me_only = [str[i:i+split_length] for i in range(0, len(str), split_length)]

new_following_them_only = [str[i:i+split_length] for i in range(0, len(str), split_length)]
nolonger_following_them_only = [str[i:i+split_length] for i in range(0, len(str), split_length)]

# WEBHOOK SENDING
# WEBHOOK CONFIG
webhook = DiscordWebhook(url=discord_webhook_url)
footer_text = "Silverarmor's Instagram tracking of " + scrape_username

# # Webhook Initial Message
# webhook

# nolonger_following_me_only
for msg in nolonger_following_me_only:
    # Create embed object for webhook
    embed = DiscordEmbed(title="Users who stopped following you :angry:", description=msg, color="FF0000")
    embed.set_timestamp()
    embed.set_footer(text=footer_text)
    # Add embed object to webhook
    webhook.add_embed(embed)
    # Send webhook
    response = webhook.execute()
    time.sleep(1.5)


# new_following_me_only
for msg in new_following_me_only:
    # Create embed object for webhook
    embed = DiscordEmbed(title="Users who started following you", description=msg, color="008000")
    embed.set_timestamp()
    embed.set_footer(text=footer_text)
    # Add embed object to webhook
    webhook.add_embed(embed)
    # Send webhook
    response = webhook.execute()
    time.sleep(1.5)

# new_following_them_only
for msg in new_following_them_only:
    # Create embed object for webhook
    embed = DiscordEmbed(title="Users you started following", description=msg, color="FFFF00")
    embed.set_timestamp()
    embed.set_footer(text=footer_text)
    # Add embed object to webhook
    webhook.add_embed(embed)
    # Send webhook
    response = webhook.execute()
    time.sleep(1.5)

# nolonger_following_them_only
for msg in nolonger_following_them_only:
    # Create embed object for webhook
    embed = DiscordEmbed(title="Users you stopped following", description=msg, color="FFA500")
    embed.set_timestamp()
    embed.set_footer(text=footer_text)
    # Add embed object to webhook
    webhook.add_embed(embed)
    # Send webhook
    response = webhook.execute()
    time.sleep(1.5)

# Webhook Final Message

print("Completed")