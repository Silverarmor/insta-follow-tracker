from instaclient import InstaClient
from instaclient.errors import *
from credentials import *
import os
from os import path
from datetime import datetime
from discord_webhook import DiscordWebhook, DiscordEmbed
import time
import gspread
import sys

"""REMEMBER TO UPDATE ME"""
version = "v1.3.1"


# Initialise Time
now = datetime.now()
init_time = now.strftime("%H:%M:%S")
init_time_with_day = now.strftime("%Y-%m-%d %H:%M:%S")

# Webhook Config
webhook = DiscordWebhook(url=discord_webhook_url, avatar_url="https://i.imgur.com/IpIG5TP.png", username="Instagram Statistics Tracker")

embed = DiscordEmbed(title="Initialised", description="Initialised at " + init_time_with_day, color=0xFEFEFE)
embed.set_footer(text=version)
embed.add_embed_field(name="Tracking ", value=scrape_username, inline=False)
webhook.add_embed(embed) # Add embed object to webhook
response = webhook.execute() # Send Webhook
webhook.remove_embed(0)

# # Uncomment if you want to prompt user for account to scrape. Else will use credentials.py's version
# scrape_username = input("Enter an Instagram account's username to scrape it's data: ")

# CREDIT
# https://medium.com/scrape-instagram-followers/scrape-instagram-followers-with-python-eba64e84048

print("Initialised. Starting login & scrape")

# ! SCRAPING

# Create a instaclient object. Place as driver_path argument the path that leads to where you saved the chromedriver.exe file
client = InstaClient(driver_path=driver_path, localhost_headless=True)

# # Backup where headless is not desired.
# client = InstaClient(driver_path=driver_path)

try:
    # Login
    client.login(username=username, password=password)
except VerificationCodeNecessary:
    # This error is raised if the user has 2FA turned on.
    code = input('Enter the 2FA security code generated by your Authenticator App or sent to you by SMS')
    client.input_verification_code(code)
except SuspisciousLoginAttemptError as error:
    # This error is raised by Instagram's anti-bot measures
    if error.mode == SuspisciousLoginAttemptError.EMAIL:
        code = input('Enter the security code that was sent to you via email: ')
    else:
        code = input('Enter the security code that was sent to you via SMS: ')
    client.input_security_code(code)

print("Logged in")
time.sleep(5) # Sleep 5 seconds to not be a bot

# Scrape Instagram followers
try:
    # Try to get the users following the scrape user, as a Tuple
    followers_scrape = client.get_followers(user=scrape_username, count=None, use_api=True, callback_frequency=100)
    # Changing from Tuple to List (Taking only the first item in Tuple)
    followers_scrape = followers_scrape[0]
    followers = list(map(str, followers_scrape))
    del followers_scrape
except InvalidUserError:
    # Exception raised if the username is not valid
    print('The username is not valid')
except PrivateAccountError:
    # Exception raised if the account you are trying to scrape is private
    print('{} is a private account'.format(scrape_username))
except:
    client.disconnect()

time.sleep(5) # Sleep 5 seconds to chill out

# Scrape Instagram following
try:
    # Try to get the users following the scrape user, as a Tuple
    following_scrape = client.get_following(user=scrape_username, count=None, use_api=True, callback_frequency=100)
    # Changing from Tuple to List (Taking only the first item in Tuple)
    following_scrape = following_scrape[0]
    following = list(map(str, following_scrape))
    # following = [str(a) for a in following_scrape]
    del following_scrape
except InvalidUserError:
    # Exception raised if the username is not valid
    print('The username is not valid')
except PrivateAccountError:
    # Exception raised if the account you are trying to scrape is private
    print('{} is a private account'.format(scrape_username))
except:
    client.disconnect()

time.sleep(5) # Sleep 5 seconds to chill out

# Scrape Instagram profile information
try:
    # Scrape profile into 'profile' object
    profile = client.get_profile(scrape_username)
except:
    client.disconnect()
    print("COULD NOT GET PROFILE INFORMATION")

time.sleep(5) # Sleep 5 seconds to chill out

# Closing the client to prevent memory leaks
client.disconnect()

print("Scraping complete & client disconnected. Starting data processing...")

# DATA PROCESSING & READING/SAVING TO FILE

# by default, program should not terminate early
terminate_early = False

# Reading files
if os.path.exists('followers.txt'):
    with open('followers.txt', 'r') as filehandle:
        old_followers = [current_place.rstrip() for current_place in filehandle.readlines()]
else:
    print("followers file does not exist, skipping reading...")
    terminate_early = True
    
if os.path.exists('following.txt'):
    with open('following.txt', 'r') as filehandle:
        old_following = [current_place.rstrip() for current_place in filehandle.readlines()]
else:
    print("following file does not exist, skipping reading...")
    terminate_early = True


# Comparing old and current lists
if os.path.exists('followers.txt') and os.path.exists('following.txt'):
    new_followers = list(set(followers) - set(old_followers))
    nolonger_followers = list(set(old_followers) - set(followers))
    new_following = list(set(following) - set(old_following))
    nolonger_following = list(set(old_following) - set(following))

    # # TEST THAT SCRAPE IS VALID
    # limit = 30

    # if len(new_followers) >= limit or len(nolonger_followers) >= limit or len(new_following) >= limit or len(nolonger_following) >= limit or profile.name == None:
    #     # Send Error Webhook
    #     embed = DiscordEmbed(title="Error", description="Encountered an error", color=0xFF0000)
    #     data_summary = "**Users who started following you** - " + str(len(new_followers)) + "\n**Users who stopped following you** - " + str(len(nolonger_followers)) + "\n**Users you started following** - " + str(len(new_following)) + "\n**Users you stopped following** - " + str(len(nolonger_following))
    #     embed.add_embed_field(name="Summary", value=data_summary, inline=False)
    #     webhook.add_embed(embed) # Add embed object to webhook
    #     response = webhook.execute() # Send Webhook
    #     webhook.remove_embed(0)

    #     # Write Error data to files. (NOTE IT OVERWRITES)
    #     with open('followers_error.txt', 'w') as filehandle:
    #        filehandle.writelines("%s\n" % user for user in followers)
    #     with open('following_error.txt', 'w') as filehandle:
    #       filehandle.writelines("%s\n" % user for user in following)
    #     with open('new_followers_error.txt', 'w') as filehandle:
    #       filehandle.writelines("%s\n" % user for user in new_followers)
    #     with open('nolonger_followers__error.txt', 'w') as filehandle:
    #       filehandle.writelines("%s\n" % user for user in nolonger_followers)
    #     with open('new_following_error.txt', 'w') as filehandle:
    #       filehandle.writelines("%s\n" % user for user in new_following)
    #     with open('nolonger_following_error.txt', 'w') as filehandle:
    #       filehandle.writelines("%s\n" % user for user in nolonger_following)

    #     if path.exists("ERROR.txt"):
    #         sys.exit()

    #     f = open('ERROR.txt', 'w')
    #     f.write("ERROR")
    #     f.close()

    #     # Restarts the script.
    #     os.execv(sys.executable, ['python3.9'] + sys.argv)

else:
    print("Skipping comparing old and current lists. Loading the lists as full")
    new_followers = followers
    new_following = following
    # Set nolonger vars as empty lists to prevent errors.
    nolonger_followers = []
    nolonger_following = []


# Overwriting files with new data.
with open('followers.txt', 'w') as filehandle:
    filehandle.writelines("%s\n" % user for user in followers)

with open('following.txt', 'w') as filehandle:
    filehandle.writelines("%s\n" % user for user in following)

if terminate_early == True:
    sys.exit("Terminated Early since followers/following file was empty")

# Removing unnecesary text for user readability. "Profile<abc.def>" to "abc.def"
new_followers = [a[8:-1] for a in new_followers]
new_following = [a[8:-1] for a in new_following]
nolonger_followers = [a[8:-1] for a in nolonger_followers]
nolonger_following = [a[8:-1] for a in nolonger_following]
followers = [a[8:-1] for a in followers]
following = [a[8:-1] for a in following]

# Putting Lengths into variable since I'm lazy.
length_new_followers = len(new_followers)
length_nolonger_followers = len(nolonger_followers)
length_new_following = len(new_following)
length_nolonger_following = len(nolonger_following)


# Converting into comma separated string for readability
"""NOTE THIS ALSO CHANGES VARS FROM LIST to STR"""
new_followers = (', '.join(new_followers))
nolonger_followers = (', '.join(nolonger_followers))
new_following = (', '.join(new_following))
nolonger_following = (', '.join(nolonger_following))
followers_as_string = (', '.join(followers))
following_as_string = (', '.join(following))


# Creating identicals for gspread use. String format with commas, but underscores NOT escaped.
sheet_new_followers = new_followers
sheet_nolonger_followers = nolonger_followers
sheet_new_following = new_following
sheet_nolonger_following = nolonger_following


# Escaping any underscores - to prevent discord formatting
new_followers = new_followers.replace("_", "\\_")
nolonger_followers = nolonger_followers.replace("_", "\\_")
new_following = new_following.replace("_", "\\_")
nolonger_following = nolonger_following.replace("_", "\\_")


# Splitting string into 1000 characters per list, since webhooks' embed description are limited to 1024 characters
# Maxmimum message length? Will split message(s) into this number if required.
# Split Function
def string_divide(string, div):
       list = []
       for i in range(0, len(string), div):
           list.append(string[i:i+div])
       return list


# How many chars in each string in the list?
split_length = 1000

# Splitting
new_followers = string_divide(new_followers, split_length)
nolonger_followers = string_divide(nolonger_followers, split_length)
new_following = string_divide(new_following, split_length)
nolonger_following = string_divide(nolonger_following, split_length)


# WEBHOOK SENDING

# # Webhook Data Message
# VARS
data_description = "**Ran Successfully**\nTracking " + scrape_username
data_details = "**Name** - " + str(profile.name) + "\n**Private** - " + str(profile.is_private) + "\n**Business Account** - " + str(profile.is_business_account) +  "\n**Posts Count** - " + str(profile.post_count)
data_summary  = "**Users who started following you** - " + str(length_new_followers) + "\n**Users who stopped following you** - " + str(length_nolonger_followers) + "\n**Users you started following** - " + str(length_new_following) + "\n**Users you stopped following** - " + str(length_nolonger_following)
data_bio = "```" + profile.biography + "```"  # placing bio in triple backticks for code block

# Colours
color_data = 0x7289da
color_nolonger_followers = 0xFF0000
color_new_followers = 0x00FF00
color_nolonger_following = 0x0000FF
color_new_following = 0xFF8C00
color_no_change = 0xFFFFFF


# General Data Webhook
embed = DiscordEmbed(title="Silverarmor's Instagram Tracker", description=data_description, color=color_data)
embed.set_timestamp()
embed.set_footer(text="Initialised at " + str(init_time))

embed.set_thumbnail(url='https://i.imgur.com/IpIG5TP.png')

embed.add_embed_field(name="Basic Data", value="**Followers Count** - " + str(profile.follower_count) + "\n**Following Count** - " + str(profile.followed_count), inline=False)
embed.add_embed_field(name="Bio", value=data_bio, inline=False)
embed.add_embed_field(name="Summary", value=data_summary, inline=False)
embed.add_embed_field(name="Details", value=data_details, inline=False)


# Send General Data Webhook
webhook.add_embed(embed)
response = webhook.execute()
webhook.remove_embed(0)
time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting


# nolonger_followers
if len(nolonger_followers) > 0:
    for msg in nolonger_followers:
        # Create embed object for webhook
        embed = DiscordEmbed(title="Users who stopped following you :angry:", description=msg, color=color_nolonger_followers)
        # Add embed object to webhook
        webhook.add_embed(embed)
        # Send Webhook
        response = webhook.execute()
        webhook.remove_embed(0)
        time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting

elif len(nolonger_followers) == 0:
    # Create embed object for webhook
    embed = DiscordEmbed(title="Users who stopped following you", description="None today!", color=color_no_change)
    # Add embed object to webhook
    webhook.add_embed(embed)
    # Send Webhook
    response = webhook.execute()
    webhook.remove_embed(0)
    time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting


# new_followers
if len(new_followers) > 0:
    for msg in new_followers:
        # Create embed object for webhook
        embed = DiscordEmbed(title="Users who started following you", description=msg, color=color_new_followers)
        # Add embed object to webhook
        webhook.add_embed(embed)
        # Send Webhook
        response = webhook.execute()
        webhook.remove_embed(0)
        time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting

elif len(new_followers) == 0:
    # Create embed object for webhook
    embed = DiscordEmbed(title="Users who started following you", description="None today!", color=color_no_change)
    # Add embed object to webhook
    webhook.add_embed(embed)
    # Send Webhook
    response = webhook.execute()
    webhook.remove_embed(0)
    time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting


# nolonger_following
if len(nolonger_following) > 0:
    for msg in nolonger_following:
        # Create embed object for webhook
        embed = DiscordEmbed(title="Users you stopped following", description=msg, color=color_nolonger_following)
        # Add embed object to webhook
        webhook.add_embed(embed)
        # Send Webhook
        response = webhook.execute()
        webhook.remove_embed(0)
        time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting

elif len(nolonger_following) == 0:
    # Create embed object for webhook
    embed = DiscordEmbed(title="Users you stopped following", description="None today!", color=color_no_change)
    # Add embed object to webhook
    webhook.add_embed(embed)
    # Send Webhook
    response = webhook.execute()
    webhook.remove_embed(0)
    time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting


# new_following
if len(new_following) > 0:
    for msg in new_following:
        # Create embed object for webhook
        embed = DiscordEmbed(title="Users you started following", description=msg, color=color_new_following)
        # Add embed object to webhook
        webhook.add_embed(embed)
        # Send Webhook
        response = webhook.execute()
        webhook.remove_embed(0)
        time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting

elif len(new_following) == 0:
    # Create embed object for webhook
    embed = DiscordEmbed(title="Users you started following", description="None today!", color=color_no_change)
    # Add embed object to webhook
    webhook.add_embed(embed)
    # Send Webhook
    response = webhook.execute()
    webhook.remove_embed(0)
    time.sleep(0.5) # Sleep .5 secs to prevent ratelimiting

print("Webhooks Completed")

# LOGGING TO GOOGLE SHEETS

# Authenticating
gc = gspread.service_account(filename=service_account_path)
# Opening Spreadsheet
spreadsheet = gc.open_by_key(sheet_key)
# Selecting Worksheet
worksheet = spreadsheet.worksheet(scrape_username)

# Creating data
"""
Creating row_data variable (list) for appending to Worksheet
init_time_with_day: Timestamp with date.
profile.follower_count: Number of followers
profile.followed_count: Number of followings
profile.post_count: Number of posts
profile.biography: bio
profile.is_private: private?
profile.username: username
profile.name: display name

x2 of each, length and then string:
    nolonger_followers
    new_followers
    nolonger_following
    new_following

followers_as_string
following_as_string
"""

row_data = []
row_data.append(str(init_time_with_day))
row_data.append(str(profile.follower_count)) #int
row_data.append(str(profile.followed_count)) #int
row_data.append(str(profile.post_count)) #int
row_data.append(str(profile.biography))
row_data.append(str(profile.username))
row_data.append(str(profile.name))
row_data.append(str(profile.is_private)) #bool
row_data.append(str(profile.is_verified)) #bool
row_data.append(str(profile.is_business_account))
row_data.append(str(length_nolonger_followers)) #int
row_data.append(str(sheet_nolonger_followers)) #list
row_data.append(str(length_new_followers))
row_data.append(str(sheet_new_followers)) #list
row_data.append(str(length_nolonger_following))
row_data.append(str(sheet_nolonger_following)) #list
row_data.append(str(length_new_following))
row_data.append(str(sheet_new_following)) #list
row_data.append(str(followers_as_string))
row_data.append(str(following_as_string))

# Appending to Worksheet
worksheet.append_row(row_data, value_input_option="USER_ENTERED", insert_data_option="INSERT_ROWS")

print("Sheet Updated")
